// let x = 4; print(x + 12)

// let 2 = 1 // segaults

if 1 < 2 {
    var x = 4
    while x < 8 {
        print(x)
        x = x + 1
    }
}

for var i = 0; i < 10; i++ {

}

for ; i < 10; i++ {

}

for var i = 0;; i++ {
    
}

for ;; i++ {

}

for ;; {

}

let x = Vector<i32>()
for y in x {
    print(y as i16)
}

f32
char
bool

fun guac = p: i32, q: i16 ==> p + (i32) q

// closures? this would be weird on multiple lines without {}s
// definitely scrap this
let x = p: i32 ==> print(p)
let x = p: i32 -> i32 ==> print(p); p


let x: i16 = function()
let x = function() as i16

let x: i1 = true

let i = { 2 + 1 }

// closures -> could make these fully type infered using the algorithms from PL based on the AST?
let i = { x - 1 + 4 } in (x: i32) -> i32

let i = {
    x - 1 + 4
} in (x: i32) -> i32

let i = { (x: i32) -> i32
    x - 4 + 1
}

let z = i(4)

// brackets delay execution, area = x + y computes it immediately
struct r = { x: i32, y: i32, area = { x + y } }
r(x: mine, y: yours);
r.area


match x with {
    var p: i32 ==> p + 1
}


// write a verify function for multiple branch control statements to make
// sure ret type is consistent
let x = if y < 4 { emit 8 } else { emit 9 }


let x: [i32] = for var i = 0; i < 10; i++ { if i < 3 { emit i } }
x -> [0, 1, 2]


let y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let x = for y in array { if y < 3 { emit y } }
x -> [0, 1, 2]


emit keyword will return a value from the control expression
emit y -> and return
emit::y -> emit as part of array?
